<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[android 注解]]></title>
    <url>%2F2018%2F06%2F21%2Fandroid-%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[注解是从Java1.5开始引入的，当前许多java框架中大量使用注解，如Hibernate、Jersey、Spring。而在Android中，大名鼎鼎的Retrofit，ButterKnife都使用了注解的方式。我们在写Android页面的时候，经常会findViewById来绑定控件，当一个页面非常复杂的时候，这个工作就是个体力活了，于是ButterKnife就应运而生了，类似的还有之前的XUtils等，但是目前使用的最广泛的还是ButterKnife，用法简单，功能完善，持续维护。而这仅仅是在绑定控件领域的注解框架，另外还有EventBus方便我们实现组建间通讯，ParcelableGenerator可实现自动将任意对象转换为Parcelable类型，方便对象传输，等等，各种功能强大的注解都有。（来自binbinqq86的描述） 注解元注解： @Documented —— 指明拥有这个注解的元素可以被javadoc类的工具文档化。 @Target——指示该注解可以注解的程序元素。该元注解的取值可以为TYPE,METHOD,CONSTRUCTOR,FIELD等。如果Target元注解没有出现，那么定义的注解可以应用于程序的任何元素。 @Inherited——指示允许子类继承父类的注解 @Retention——指明了该Annotation的生命周期。RetentionPolicy取值为SOURCE,CLASS,RUNTIME。 @Retention(RetentionPolicy.SOURCE) //注解仅存在于源码中，在class字节码文件中不包含 @Retention(RetentionPolicy.CLASS) // 默认的保留策略，注解会在class字节码文件中存在，但运行时无法获得 @Retention(RetentionPolicy.RUNTIME) // 注解会在class字节码文件中存在，在运行时可以通过反射获取到 内建注解：java提供的内建注解 @Override——当我们想要复写父类中的方法时，我们需要使用该注解去告知编译器我们想要复写这个方法。这样一来当父类中的方法移除或者发生更改时编译器将提示错误信息。 @Deprecated——当我们希望编译器知道某一方法不建议使用时，我们应该使用这个注解。Java在javadoc 中推荐使用该注解，我们应该提供为什么该方法不推荐使用的原因以及替代的方法。 @SuppressWarnings——这个仅仅是告诉编译器忽略特定的警告信息，例如在泛型中使用原生数据类型。它的保留策略是SOURCE（译者注：在源文件中有效）并且被编译器丢弃。 android提供的内建注解 因为没有用到，需要的时候可以参考这个文章 android注解 自定义注解的创建和使用通过创建一个自定义注解，来简化我们findViewById()和setContentView()的步骤 12345678910111213141516import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * 新建了一个自定义注解类 */@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.FIELD,ElementType.TYPE&#125;)public @interface BindId &#123; int value() default View.NO_ID; //设置value的默认值 int test() default -1;&#125; 注解类的实现类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class BindIdApi &#123; public static void bindId(Activity obj) &#123; Class&lt;?&gt; cls = obj.getClass(); //获取传进来的activity的实体类 //使用反射调用setContentView if (cls.isAnnotationPresent(BindId.class)) &#123; //如果此元素上存在指定类型的注释，则返回true，否则返回false。 BindId bindId = cls.getAnnotation(BindId.class); //获取这个类的bindId注解 int id = bindId.value(); //得到注解的值 try &#123; Method method = cls.getMethod("setContentView", int.class); //根据传入的方法名，和方法的参数类型，来获取 某个类内部某个方法的对象 method.setAccessible(true); //访问修饰符设置为public method.invoke(obj, id); //通过传入类的对象和id ，来调用invoke方法。 &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; //使用反射调用findViewById Field[] fields = cls.getFields(); //获取域的集合 for (Field field : fields) &#123; if (field.isAnnotationPresent(BindId.class)) &#123; //判断此元素是否包含指定类型的注解 BindId bindId2 = field.getAnnotation(BindId.class); int id2 = bindId2.value(); try &#123; Method method2 = cls.getMethod("findViewById", int.class); method2.setAccessible(true); Object view = method2.invoke(obj, id2); field.setAccessible(true); field.set(obj, view); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 使用自定义注解 123456789101112@BindId(R.layout.activity_annotation)public class AnnotationActivity extends AppCompatActivity &#123; @BindId(R.id.tv_annotation) TextView textView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); BindIdApi.bindId(this); textView.setBackgroundColor(Color.RED); &#125;&#125; 自定义注解的理解：@interface 关键字用来声明一个注解，自动继承 java.lang.annotation.Annotaion 接口。 里面的每一个方法表示声明了一个可配置的参数，方法名即位参数名。 如 int value() default 0; 表明给value的默认值为0,方法内部还可以包含其他注解。我们可以使用元注解来注解当前的这个注解。 返回值类型就是参数的类型且只能为 八种基本数据类型 、 Class 、 String 、 Enum 、Annotations类型以及上述类型所组成的数组。 通过 default 关键字声明参数的默认值。如果只有一个参数成员最好命名为 value()。 注解元素必须有确定的值，要么在定义注解元素时默认值指定，要么使用此注解时指定。非基本类型注解元素的值不可为 null 在另一个注解的实现类中，我们通过传入的activity对象来判断这个活动类是否包含有某个注解。如果包含的话，就获取这个注解的实例保存起来。并且把注解的属性的值保存起来。 接着便可以通过反射来执行类的方法，设置或获取属性的值。 在java代码中 @BindId(R.layout.activity_annotation) 括号中的int值就可以通过我们在注解中声明的属性名来获取 什么时候调用实现类，那么自定义注解就什么时候被调用 更加详细的学习地址：文章1 文章2]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[markdown常用语法]]></title>
    <url>%2F2018%2F06%2F19%2Fmarkdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[markdown 的常用语法记录，需要注意的是 每输入一个标签后面要间隔一个空格 否则没有效果。 标题123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 一级标题二级标题三级标题四级标题五级标题六级标题列表有序列表1231. 有序12. 有序2只需要输入数字加小数点 就可以了 有序1 有序2 无序列表12345678* 列表1* 列表2+ 列表3* 列表6- 列表5- 列表4 * + - 都可以用来指示无序列表 ，只是不同的符号放在一起的时候，两个不同符号之间的字段间隔会比以前拉大。 列表1 列表2 列表3 列表6 列表5 列表4 引用1&gt;这是一句引用 这是一句引用 分割线1234***---* * *效果都是一样的 代码块1234` System.out.println(&quot;a&quot;);`上面这个用于只想要输出显示一小段代码 ... 1上面这个则是要显示一大块代码 前面的~~~后面加上语言名称 则可以代码高亮 System.out.println(&quot;a&quot;);1...一大块代码 强调1234**加粗**__加粗__*斜体*_斜体_ 加粗加粗斜体_斜体_ 链接123[百度](http://www.baidu.com)一下[]里面的内容将是能够响应点击并且跳转的文字。 ()里面的内容将是能够跳转到的网站 百度一下微软 引用图片1234567![Alt text](图片地址 &quot;optional title&quot;)![Alt text](https://raw.githubusercontent.com/IChanr/IMG/master/intentservice.png) Alt text:图片的Alt标签,用来描述图片的关键字,可以留空白只[] 图片地址： 如果要引用github上的图片，需要复制的是点击download后的那个链接 optional title:鼠标悬置于图片上时显示的文字 把图片放在本地真的是十分杂乱 所以还是放在图床上比较合适。 表格12345678居右|剧中|moren-:|:-:|-a|b|cd|e|fg|h|j不管怎么样 第一行都是显示表头 第二行显示的是接下来填入的数据的对齐方式 - 这个符号表示下面填写的数据 ：放在-的左边的表示这一字段的数据都向左对齐，：在-的右边则表示这字段的数据都向右对齐，-:-则表示这一字段的数据居中显示， 默认 - 居左 居右 剧中 moren a b c d e f g h j]]></content>
      <categories>
        <category>markdown</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[json解析的多种方式]]></title>
    <url>%2F2018%2F06%2F19%2Fjson%E8%A7%A3%E6%9E%90%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[学习json的解析方法! 什么是JSON? JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。通常用于向服务器发起请求时使用的数据格式。 JSON 语法规则在 JS 语言中，一切都是对象。因此，任何支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。但是对象和数组是比较特殊且常用的两种类型：对象表示为键值对数据由逗号分隔花括号保存对象方括号保存数组 JSON 键/值对JSON 键值对是用来保存 JS 对象的一种方式，和 JS 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值：{“firstName”: “Json”} 使用Android自带的Json库解析{&quot;result&quot;:&quot;成功&quot;,&quot;resultCode&quot;:200&quot;,mList&quot;:[{&quot;content&quot;:&quot;内容0&quot;,&quot;title&quot;:&quot;标题0&quot;},{&quot;content&quot;:&quot;内容1&quot;,&quot;title&quot;:&quot;标题1&quot;},{&quot;content&quot;:&quot;内容2&quot;,&quot;title&quot;:&quot;标题2&quot;},{&quot;content&quot;:&quot;内容3&quot;,&quot;title&quot;:&quot;标题3&quot;},{&quot;content&quot;:&quot;内容4&quot;,&quot;title&quot;:&quot;标题4&quot;}]} 我们先来看看如何解析这一串数据 12345678910111213141516private void jsonAnalysis(String str) throws JSONException &#123; JSONObject jsonObject = new JSONObject(str); //将字符串转换为json对象 //每一个&#123;&#125;表示一个json对象，[]表示一个json数组 内部有多个json对象需要循环取出 int code = jsonObject.getInt(&quot;resultCode&quot;); String result = jsonObject.getString(&quot;result&quot;); Log.d(TAG, &quot;jsonAnalysis: 状态码：&quot; + code); Log.d(TAG, &quot;jsonAnalysis: 结果&quot; + result); JSONArray jsonArray = jsonObject.getJSONArray(&quot;mList&quot;); for (int i = 0; i &lt; jsonArray.length(); i++) &#123; String title = jsonArray.getJSONObject(i).getString(&quot;title&quot;); String content = jsonArray.getJSONObject(i).getString(&quot;content&quot;); Log.d(TAG, &quot;jsonAnalysis: 标题：&quot; + title); Log.d(TAG, &quot;jsonAnalysis: 内容：&quot; + content); &#125; &#125; 通过JSONObject 我们可以根据已知的键值来获取想要的值，并且还可以通过这个类来生成Json格式的字符串 使用Gson解析数据 Gson是google推出的一款解析Json的开源框架 通过Gson想要解析上面的字符串则变得更为的简单，首先新建一个数据的Bean类（用与存储最后的解析结果） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class NewsBean &#123; private String result; private int resultCode; private List&lt;Content&gt; mList; public List&lt;Content&gt; getmList() &#123; return mList; &#125; public void setmList(List&lt;Content&gt; mList) &#123; this.mList = mList; &#125; public static class Content &#123; private String title; private String content; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125; &#125; public String getResult() &#123; return result; &#125; public void setResult(String result) &#123; this.result = result; &#125; public int getResultCode() &#123; return resultCode; &#125; public void setResultCode(int resultCode) &#123; this.resultCode = resultCode; &#125;&#125; 1234567891011private void gsonAnalysis(String str)&#123; Gson gson=new Gson(); NewsBean newsBean=gson.fromJson(str,NewsBean.class); Log.d(TAG, &quot;gsonAnalysis: &quot;+newsBean.getResult()); Log.d(TAG, &quot;gsonAnalysis: &quot;+newsBean.getResultCode()); List&lt;NewsBean.Content&gt; m=newsBean.getmList(); for (int i = 0; i &lt; m.size(); i++) &#123; Log.d(TAG, &quot;gsonAnalysis: &quot;+m.get(i).getContent()); Log.d(TAG, &quot;gsonAnalysis: &quot;+m.get(i).getTitle()); &#125;&#125; 通过对比，可能会觉得代码量变多，变得更加麻烦了，但是当你的json字符串是一大串的时候，键值更多的时候，使用JSONObject就变得十分的困难了，当键值变化了，每个地方都要修改，而在Gson中则只需要修改Bean类。并且有插件GsonFormat可以帮我们自动生成Bean类。]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[自定义View的绘图机制(1)]]></title>
    <url>%2F2018%2F06%2F15%2F%E8%87%AA%E5%AE%9A%E4%B9%89View%E7%9A%84%E7%BB%98%E5%9B%BE%E6%9C%BA%E5%88%B6(1)%2F</url>
    <content type="text"><![CDATA[学习自定义View的理解 Android XML绘图 XML在Android系统中可不仅仅是Java中的一个布局文件、配置列表。在Android开发者的手上，它甚至可以变成一张画、一幅图。Android的开发者给XML提供了几个强大的技能来帮助我们实现这一功能。 绘制Bitmap使用方法: 通过在在drawable目录下新建一个xml文件,使用bitmap标签 标签指向图片的位置,这就是一个xml就是一个可以供我们使用的图片 将一张图转换为Bitmao, 如果你愿意还可以设置一些另外的属性`&lt;?xml version=”1.0” encoding=”utf-8”?&gt; ` 布局文件中的引用&lt;ImageView android:src=&quot;@drawable/getbitmap&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; Java中的用法Drawable drawable=getResources().getDrawable(R.drawable.getbitmap,null); mImageView.setImageDrawable(drawable); Shape说明:通过Shape可以在XML中绘制各种形状 Shape 标签中通过android:shape=[“rectangle” | “oval” | “line” | “ring”] &gt; 指定要绘制的是什么形状的图案 Shape的内部标签 corners则是用来指定圆角半径 当shape=rectangle时可用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 xmlns:android=http://schemas.android.com/apk/res/android //默认为rectangle android:shape=[&quot;rectangle&quot; | &quot;oval&quot; | &quot;line&quot; | &quot;ring&quot;] &gt; &lt;corners //当shape=“rectangle”时使用 //半径，会被后面的单个半径属性覆盖，默认为1dp android:radius=&quot;integer&quot; android:topLeftRadius=&quot;integer&quot; android:topRightRadius=&quot;integer&quot; android:bottomLeftRadius=&quot;integer&quot; android:bottomRightRadius=&quot;integer&quot; /&gt; &lt;gradient //渐变 android:angle=&quot;integer&quot; android:centerX=&quot;integer&quot; android:centerY=&quot;integer&quot; android:centerColor=&quot;integer&quot; android:endColor=&quot;color&quot; android:gradientRadius=&quot;integer&quot; android:startColor=&quot;color&quot; android:type=[&quot;linear&quot; | &quot;radial&quot; | &quot;sweep&quot;] android:useLevel=[&quot;true&quot; | &quot;false&quot;] /&gt; &lt;padding android:left=&quot;integer&quot; android:top=&quot;integer&quot; android:right=&quot;integer&quot; android:bottom=&quot;integer&quot; /&gt; &lt;size //指定大小，一般用在imageview配合scaleType属性使用 android:width=&quot;integer&quot; android:height=&quot;integer&quot; /&gt; &lt;solid //填充颜色 android:color=&quot;color&quot; /&gt; &lt;stroke //指定边框 android:width=&quot;integer&quot; android:color=&quot;color&quot; //虚线宽度 android:dashWidth=&quot;integer&quot; //虚线间隔宽度 android:dashGap=&quot;integer&quot; /&gt; &lt;/shape&gt;``` ## Layer**Layer是在Photoshop中非常常用的功能。在Android中，同样可以通过Layer来实现类似Photoshop中图层的概念。**```&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:drawable=&quot;@drawable/ic_launcher&quot;/&gt; &lt;item android:drawable=&quot;@drawable/ic_launcher&quot; android:left=&quot;50dp&quot; android:top=&quot;50dp&quot; android:right=&quot;50dp&quot; android:bottom=&quot;50dp&quot;/&gt; &lt;!-- 用法都是相同的,先添加的图片位于底层,后添加的位于顶层 --&gt;&lt;/layer-list&gt; SelectorSelector的作用在于帮助开发者实现静态绘图中的事件反馈，通过给不同的事件设置不同的图像，从而在程序中根据用户输入，返回不同的效果。12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt; &lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;!--默认时的背景图片--&gt; &lt;item android:drawable=&quot;@drawable/ X1&quot; /&gt; &lt;!--没有焦点时的背景图片--&gt; &lt;item android:state_window_focused=&quot;false&quot; android:drawable=&quot;@drawable/X2&quot; /&gt; &lt;!--非触摸模式下获得焦点并单击时的背景图片--&gt; &lt;item android:state_focused=&quot;true&quot; android:state_pressed=&quot;true&quot; android:drawable=&quot;@drawable/X3&quot; /&gt; &lt;!--触摸模式下单击时的背景图片--&gt; &lt;item android:state_focused=&quot;false&quot; android:state_pressed=&quot;true&quot; android:drawable=&quot;@drawable/X4&quot; /&gt; &lt;!--选中时的图片背景--&gt; &lt;item android:state_selected=&quot;true&quot; android:drawable=&quot;@drawable/X5&quot; /&gt; &lt;!--获得焦点时的图片背景--&gt; &lt;item android:state_focused=&quot;true&quot; android:drawable=&quot;@drawable/X5&quot; /&gt; &lt;/selector&gt; 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:state_pressed=&quot;true&quot;&gt; &lt;shape android:shape=&quot;rectangle&quot;&gt; &lt;!--填充的颜色--&gt; &lt;solid android:color=&quot;#33444444&quot; /&gt; &lt;!--设置按钮的四个角为弧形--&gt; &lt;!-- android:radius弧形的半径--&gt; &lt;corners android:radius=&quot;5dip&quot; /&gt; &lt;!-- padding：Button里面的文字与Button边界的间隔--&gt; &lt;padding android:bottom=&quot;10dp&quot; android:left=&quot;10dp&quot; android:right=&quot;10dp&quot; android:top=&quot;10dp&quot; /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item&gt; &lt;shape android:shape=&quot;rectangle&quot;&gt; &lt;!--填充的颜色--&gt; &lt;solid android:color=&quot;#FFFFFF&quot; /&gt; &lt;!--设置按钮的四个角为弧形--&gt; &lt;!-- android:radius弧形的半径--&gt; &lt;corners android:radius=&quot;5dip&quot; /&gt; &lt;!-- padding：Button里面的文字与Button边界的间隔--&gt; &lt;padding android:bottom=&quot;10dp&quot; android:left=&quot;10dp&quot; android:right=&quot;10dp&quot; android:top=&quot;10dp&quot; /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/selector&gt; 总结: 通过上面的例子我就发现,在xml中绘图和在layout中设置的一些属性是相似的,androoid可以通过xml解析类来进行解析从而加载到内存中去. 在xml中创建一个&lt;bitmap标签&gt;,当然这个标签还可以设置一些透明度,布局之类的属性.之后我们可以通过这个xml加载这个个性化的视图到应用中去. &lt;Shape标签&gt; 可以自定义一个个性化的位图,可以指定他的颜色,padding,圆角的角度,size,边框的大小等风格.实际上这也就是在绘制一张图了 &lt;layer-list标签&gt; 每插入一个item就新建一个图层最后调用这个xml的时候会获得一个组合了这几个图层的一个视图,这相当于我们在ps中p图的时候为了方便自己修改或者删除视图上的一些内容,我们会每绘制一些内容就保存到一个图层中,最后通过组合的方式将这几个图层都组合起来. &lt;selector标签&gt; Selector的作用在于帮助开发者实现静态绘图中的事件反馈，通过给不同的事件设置不同的图像，从而在程序中根据用户输入，返回不同的效果。,不过只能够进行简单的视觉修改,背景色什么的.我们可以在item中嵌套以上的所有标签来更改(除了Selector)也就是我们在xml中绘制,然后把绘制的内容应用到控件中去. 使用Canvas绘制 canvas类用于直接操作图层,和我之前猜测一样, 我们在当前的图层中进行绘制和移动以左上角的那个点作为原点来绘制,这个原点是会变的,当我们调用translate(50,50) ,之后的旋转啊移动啊都是以这个移动了x,y各50个坐标点的点为参照. view中的getWidth();和getHeight();获取的是当前空前被指定的大小,不是整块屏幕的大小. Layer图层 类似ps中的图层叠加, 通过在Canvas上绘制一个新的视图来组成不同的视觉效果 总结: 新建一个Canvas时 如果没有传入一个bitmap对象,则他会在内部新建一个bitmap,这个可以通过阅读源码查看,之后我们通过canvas对象来对这个bitmap对象进行绘制. 每当我们调用save();方法的时候,canvas就会把当前视图的matrix矩阵和视图的状态到一个栈中(后入先出) 然后会返回一个int类型的值,通过这个返回值我们可以先保存起来. 在进行到后面的修改视图感觉不是自己想要的,想要恢复到之前的状态canvas.restoreToCount(int *); 把之前保存的int值传进入,那么我们之前入栈的一些视图的信息就会出栈重新设置到当前的canvas中.canvas.saveLayerAlpha(left, top, right, bottom, alpha); 新建一个指定透明度的并且指定范围的视图,这个视图是叠在我们canvas原先的bitmap上面的,因为这个新的视图可以设置透明图所以我们可以看到之前视图的一些内容. 因为Bitmap在android中如果没有明确指定大小会很容易造成内存泄漏性能上的问题.restore();则只是出一次栈,直至恢复到最初入栈的样子(出栈数不能超过入栈数)]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用GitHub和Git]]></title>
    <url>%2F2018%2F06%2F09%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8GitHub%E5%92%8CGit%2F</url>
    <content type="text"><![CDATA[Git 是一种版本控制系统 GitHub 一个代码共享平台,我们可以将代码托管在上面 这是我在学习使用Git时的笔记 #常用的配置信息: git –version 查看当前git的版本信息 git config –global user.name 获取当前登录的用户 git config –global user.email 获取当前登录用户的邮箱 git config –global user.name ‘userName’ 设置本地的用户名,当我们推送到github上时,将会显示是谁提交了这个修改 git config –global user.email ‘email’ 设置本地用户的邮箱,当我们git log 的时候可以看到是谁提交的以及邮箱 ls –al 查看当前目录下的文件和目录信息 #命令操作: git diff -u 在Git Bash上,我们使用 diff -u 某文件 某文件,就可以对比出两个文件的不同之处 ,-u可以优化显示的效果,具体可以对比加不加这个词的效果对比 +表示新添加 -表示后来减少的 (两个文件名字的先后顺序影响着我们最后的输出结果到底是新添加的还是最近才删除的) 没有加上-u 默认的添加和删除只是前面加了 &lt; 或者 &gt; 来突出这个信息 git init 在本地目录上,初始化一个本地仓库 git status 获取这个本地仓库的状况,比如被修改了? git log 获取我们提交的commit的历史记录 git add . 将我们当前目录下的所有文件添加到暂存区中 git reset 取消添加到暂存区中的内容,前提是要有添加到暂存区 git commit -m “说明” 将暂存区中的内容commit到本地仓库中 git diff 比较当前目录下的文件和暂存区中的文件的差异 git diff –staged 比较暂存区中的文件和最新提交的commit的差异 git diff commit1Id commit2Id 比较两个commit都更改了哪些内容 git branch branch1 创建一个叫做branch1的分支 git checkout branchName 切换到其他分支,我们还可以通过git log 获取到commit的id来切换到其他的提交上 git merge otherbranch 将otherbranch分支合并到当前的分支中,如果产生冲突会提示哪个文件出错,并且要我们进行修改才能进行提交. git merge –abort 如果合并不如意,通过这个命令可以恢复到合并之前的状态. git remote 查看当前本地仓库的远程仓库 ,没有输出就是没有远程仓库 git remote add origin url 添加一个远程仓库 ,origin是远程仓库在当前本地仓库的一个名称 url是远程仓库的地址 到时候需要自己填写 git remote -v 可以更加详细的显示当前远程仓库的信息 (v:verbose 详细) git push origin master 将当前的本地仓库推送到github上的远程仓库 origin当前本地仓库设置的远程仓库的地址,master当前本地仓库要上传的分支.如果远程仓库的地址是HTTPS URL 则在上传的时候就需要填写账号和密码,若使用 SSH URL则需要在本地和github上配置ssh key 官方推荐说除非你已熟悉 SSH 密钥，否则不建议你这样做。 (学习地址:https://help.github.com/articles/connecting-to-github-with-ssh/) forking 在github上clone别人的仓库并保存在github上 git clone 将远程仓库克隆到本地,克隆一个远程仓库的时候,将会在本地建立一个叫做origin的远程仓库分支和一个master的本地分支 git fetch 从远程仓库中把新提交的commit拉回到本地,然后更新远程仓库的本地分支 git merge 远程仓库的本地分支名称 将合并这两个分支,如果发生冲突就需要我们进行手动修改 git pull =git fetch+git merge git pull 简化了我们的命令,但是出现冲突我们同样需要手动修改 更多的命令指导: https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%85%B3%E4%BA%8E%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6]]></content>
  </entry>
  <entry>
    <title><![CDATA[Intent 详解]]></title>
    <url>%2F2018%2F06%2F08%2FIntent-%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Intent 是一个消息传递对象，您可以使用它从其他应用组件请求操作。尽管 Intent 可以通过多种方式促进组件之间的通信，但其基本用例主要包括以下三个： 启动 Activity：Activity 表示应用中的一个屏幕。通过将 Intent 传递给 startActivity()，您可以启动新的 Activity 实例。Intent 描述了要启动的 Activity，并携带了任何必要的数据。如果您希望在 Activity 完成后收到结果，请调用 startActivityForResult()。在 Activity 的 onActivityResult() 回调中，您的 Activity 将结果作为单独的 Intent 对象接收。如需了解详细信息，请参阅 Activity 指南。 启动服务：Service 是一个不使用用户界面而在后台执行操作的组件。通过将 Intent 传递给 startService()，您可以启动服务执行一次性操作（例如，下载文件）。Intent 描述了要启动的服务，并携带了任何必要的数据。如果服务旨在使用客户端-服务器接口，则通过将 Intent 传递给 bindService()，您可以从其他组件绑定到此服务。如需了解详细信息，请参阅服务指南。 传递广播：广播是任何应用均可接收的消息。系统将针对系统事件（例如：系统启动或设备开始充电时）传递各种广播。通过将 Intent 传递给 sendBroadcast()、sendOrderedBroadcast() 或 sendStickyBroadcast()，您可以将广播传递给其他应用。更详细的可以看这里 https://developer.android.google.cn/guide/components/intents-filters 1. 显式Intent​ 一般在构造intent的对象的时候,就指定了它的意图,通常用在程序内,知道具体的要启动哪一个activity的时候. 12Intent intent = new Intent(MainActivity.this, Main2Activity.class);startActivity(intent); ​ activity类提供了一个专门用于启动活动的方法,此外还有startSearch();用于启动服务 ​ Intent,第一个参数Context,要求提供一个启动活动的上下文,第二个参数Class,则是指定想要启动的目标活动,这样就构造出了intent的意图. 2. 隐式Intent​ 它并不明确指出需要启动哪个活动,而是交给系统去解析intent,通过与action和category的配对来启动合适的activity,如果没有匹配到相应的activity则这个程序会抛出异常并停止运行. ​ 一个Intent只能指定一个action,但是可以指定多个category ​ 通过解析，将Intent映射给可以处理此Intent的Activity、IntentReceiver或Service。 1234Intent intent=new Intent("intent1");//intent.addCategory(Intent.CATEGORY_DEFAULT);//此处并不需要添加category 因为这是一个默认的category,调用下面的时候会自动添加上这个categorystartActivity(intent); ​ 只有action和category中的内容同时能够匹配上Intent中指定的action和category时,这个活动才能响应该Intent 3. Intent Filter匹配规则​ Intent Filter就是Intent的过滤器,当我们隐式的启动系统组件的时候,就会在AndroidManiFest.xml中根据IntentFilter来筛选除合适的活动来进行启动. 现在我们知道了可以在Intent启动的时候对应设置Action、Category、DataAndType，这里设置的是为了过滤的时候对应IntentFilter匹配action、category、data。 除开过滤广播的的IntentFilter可以在代码中创建外，其它的IntentFilter都得在AndroidManifest.xml中给设置。 AndroidManiFest.xml中,每个组件可以有多个(IntentFilter)过滤器,但只要一个满足,就会启动这个activity 3.1 action匹配规则​ 123Intent intent=new Intent("intent1");//intent.setAction("..."); 通过给intent指定一个action(一个intent只能指定一个aciton,但可以指定多个category)来进行匹配,上面的两种方法都可以. 3.2 category匹配规则​ 每个过滤器可以有多个category,但是在Intent中必须把过滤器中的所有category加上,否则是无法匹配成功的. ​ intent发起意图的时候,并不是不需要category,只是它默认的会给这个intent添加一个默认的category,所以意图过滤器中必须加上默认的category(),否则因为intent会自动附加默认的category,就会造成匹配失败. 3.3 data的匹配规则​ 只有标签中指定的内容和Intent中携带的Data完全一致的时候,当前活动才可以响应该Intent ​ 不过一般在标签中都不会指定过多的内容 比如 android:scheme 为http的时候,就可以响应所有http的intent了. ​ data主要包括的就是一个URI和mimeType ,URI资源类型符,mimeType媒体类型 ​ 标签中包含了以下几种子元素，他们定义了url的匹配规则： android:scheme 匹配url中的前缀，除了“http”、“https”、“tel”…之外，我们可以定义自己的前缀 android:host 匹配url中的主机名部分，如“google.com”，如果定义为“*”则表示任意主机名 android:port 匹配url中的端口 android:path 匹配url中的路径 ​ 如果过滤器只是单纯的设置URI或者只设置了mimeType的话可以在初始化intent对象的时候调用setData(String ..)或者setType(String ..) ​ 但是,如果URI和mimeType都需要设置的话,则需要调用SetDataAndType(String …, String …); 这个方法了,因为如果先调用setData,再调用setType()方法的时候,它会清除掉前一个setData的数据,所以为了避免匹配失败,要看清楚需要匹配哪些东西. 123456public @NonNull Intent setData(@Nullable Uri data) &#123; mData = data; mType = null; //type会被设置为空 return this;&#125; 12345public @NonNull Intent setType(@Nullable String type) &#123; mData = null; //data会被设置为空 mType = type; return this;&#125; 123456public @NonNull Intent setDataAndType(@Nullable Uri data, @Nullable String type) &#123; mData = data; mType = type; //不会被设置为空 return this;&#125; 3.4 通过data调用系统应用​ intent.setData(Uri.parse(“:”)); 这个方法可以自动的判断 前:后 前就是这个数据的类型,后就是数据 我们可以将一个指定前缀的字符串转换成特定的URI类型，如：“http:”或“https:”表示网络地址类型，“tel:”表示电话号码类型，“mailto:”表示邮件地址类型，等等。 123Intent intent=new Intent(Intent.ACTION_DIAL);intent.setData(Uri.parse("tel:123456"));startActivity(intent); 3.5 android.intent.action.MAIN 与android.intent.category.LAUNCHER的区别(参考了:猴子搬来的救兵Castiel)区别一：android.intent.action.MAIN决定一个应用程序最先启动那个组件android.intent.category.LAUNCHER决定应用程序是否显示在程序列表里(说白了就是是否在桌面上显示一个图标)这两个属性组合情况：第一种情况：有MAIN,无LAUNCHER，程序列表中无图标原因：android.intent.category.LAUNCHER决定应用程序是否显示在程序列表里第二种情况：无MAIN,有LAUNCHER，程序列表中无图标原因：android.intent.action.MAIN决定应用程序最先启动的Activity，如果没有Main，则不知启动哪个Activity，故也不会有图标出现所以这两个属性一般成对出现。如果一个应用中有两个组件intent-filter都添加了android.intent.action.MAIN和android.intent.category.LAUNCHER这两个属性， 则这个应用将会显示两个图标， 写在前面的组件先运行。区别二： android.intent.category.LAUNCHER：android.intent.category.LAUNCHER决定应用程序是否显示在程序列表里，就是android开机后的主程序列表。android.intent.category.HOME：按住“HOME”键，该程序显示在HOME列表里。 4. 决解隐式Intent匹配失败时的程序崩溃123456789Intent intent = new Intent(Intent.ACTION_DIAL); intent.setData(Uri.parse("tel:123456")); PackageManager packageManager = getPackageManager(); List&lt;ResolveInfo&gt; mInfo = packageManager.queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY); if (mInfo.size() != 0) &#123; startActivity(intent); &#125; else &#123; Log.d("TAG", "onCreate: 匹配不到"); &#125; 上面的方法可以获取到匹配成功的集合,如果为0就表示匹配不到,这是条件选择不执行启动就不会导致程序崩溃了 5. Intent Filter匹配的优先级​ Intent-Filter 按照以下优先关系查找 : action&gt;category&gt;data 6. 通过Intent启动其他的应用程序7. 通过intent跨Activity传输数据​ 12345678 intent.putExtra("text",1); //通过intent传递值 启动另一个activity..... Intent intent1=getIntent(); int x=intent1.getIntExtra("text",0);//获取上一个activity传递过来的值//也可以获取一个其他类型的对象,不过该对象来实现序列化接口才可以传递过来]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Service使用指南]]></title>
    <url>%2F2018%2F06%2F08%2FService%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[服务是一种应用程序组件，表示应用程序希望在不与用户交互的情况下执行长时间运行的操作，或者为其他应用程序提供的功能。每个服务类必须 在其包中有对应的 声明AndroidManifest.xml。服务可以通过Context.startService()和 Context.bindService()来进行启动。更详细了解地址:https://developer.android.google.cn/reference/android/app/Service 1. 服务是什么? ​ 服务是一种应用程序组件，当应用程序希望在不与用户交互的情况下执行长时间运行的操作，或者为其他应用程序提供的功能。每个服务类必须在其包的AndroidManifest.xml中具有相应的声明。 ​ 特别需要注意的是,服务也是运行在主线程当中的,当你需要运行耗时任务的时候需要另外开辟子线程,否则会造成界面的卡死. ​ 需要知道的是,服务本身并不是一个线程或进程,它是依赖于创建服务时所在的应用程序进程,当应用程序停止这个服务也会终止运行. ​ 2. 异步处理:2.1 异步消息的处理机制: ​ Android中的异步消息处理机制主要由下面四部分组成. ​ 每当创建一个Handler实例的时候,它将自动绑定到创建该实例的线程上.所以当Handler在主线程中创建,里面的handlerMessage()方法执行的操作也是在主线程当中进行的. 功能 Message 可以携带少量信息,用于在不同的线程之间交互数据.可以使用what字段或arg1,arg2,obj字段携带信息. Handler 用于发送和处理Message,发送使用SendMessage(),接收则使用handleMessage(). MessageQueue 消息队列,主要存放所有通过Handler发送的消息,.每个线程中只会有一个MessageQueue对象 Looper 是MessageQueue的管家,调用Looper的loop()方法以后就会进入无限循环,每当发现消息队列中存在消息的时候,就会把消息取出,并传递到Handler的handlerMessage()方法中.和上面一样每个线程中只有一个Looper对象. 一条Message经过这样的一个流程以后,也就由子线程进入了主线程,也就可以对UI进行相对应的修改了.整个异步消息处理的核心也就是如此 2.2 使用AsyncTask: AsyncTask也是基于Handler封装而来的.由于AsyncTask是一个抽象类,因此想要使用AsyncTask就必须创建一个继承自AsyncTask的类,并指定泛型和重写以下四个方法. 用途 onPreExecute()gai 该方法会在后台任务开始执行之前调用,用于进行一些界面上的初始化操作 doInBackground(Parans …) 这个方法中的所有代码都会在子线程中进行操作,任务一旦完成就可以通过return语句来将任务的执行结果返回,如果AsyncTask的第三个泛型参数指定为Void,就可以不返回任务执行结果.(如果想要更新任务进度的话,可以调用publishProgress(Progress …)方法来完成) onProgressUpdate(Progress …) 当后台任务调用了publishProgress(Progress …),当前方法就会被调用,该方法中的参数就是在后台任务中传递过来的.在这个方法中可以对UI进行操作.利用传进来的参数就可以对界面进行更新. onPostExecute(Result) 当后台任务完成并通过return返回的时候,当前方法就被调用,返回的数据会作为参数传递到当前方法中,可以利用返回的数据来进行一些UI操作,比如提醒任务完成等… ​ 实践 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MainActivity extends AppCompatActivity &#123; private static final String TAG = "MainActivity"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mySynnc mySyn = new mySynnc(); //异步任务的初始化 mySyn.execute(); //当实现异步任务类的第一个参数指定不为空的时候,需要把要提交的参数放在.execute()中 &#125; //通过代码实践可以直观的看出整个异步任务的执行流程 class mySynnc extends AsyncTask&lt;Void, Integer, Boolean&gt; &#123; @Override protected void onPreExecute() &#123; super.onPreExecute(); Log.d(TAG, "onPreExecute: 初始化"); &#125; @Override protected Boolean doInBackground(Void... voids) &#123; Log.d(TAG, "doInBackground: 后台"); publishProgress(123); return null; &#125; @Override protected void onPostExecute(Boolean aBoolean) &#123; super.onPostExecute(aBoolean); Log.d(TAG, "onPostExecute: 任务完成,进入收尾阶段"); &#125; @Override protected void onProgressUpdate(Integer... values) &#123; super.onProgressUpdate(values); Log.d(TAG, "onProgressUpdate: 更新"); &#125; &#125;&#125; 3. 服务的基本用法: ​ 通过androidstudio右键新建一个继承自Service的类,并在内部实现相对应的方法,因为服务是四大组件之一所以必须在ManiFest.xml中进行注册,否则无法使用(没反应). 3.1 定义一个服务:​ 1234567891011121314151617181920212223242526272829303132public class MyService extends Service &#123; private static final String TAG = "MyService"; public MyService() &#123; Log.d(TAG, "MyService: "); &#125; @Override public IBinder onBind(Intent intent) &#123; Log.d(TAG, "onBind: "); // TODO: Return the communication channel to the service. return null; &#125; @Override public void onCreate() &#123; super.onCreate(); Log.d(TAG, "onCreate: "); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Log.d(TAG, "onStartCommand: "); return super.onStartCommand(intent, flags, startId); &#125; @Override public void onDestroy() &#123; super.onDestroy(); Log.d(TAG, "onDestroy: "); &#125;&#125; ​ 定义一个服务必须重写 onBind(..) 方法,因为这是一个抽象方法,在实现类中必须被实例. ​ onCreate()方法在服务被创建时会被调用. ​ onStartCommond(…) 方法在每次服务启动的时候调用. ​ onDestroy() 方法 当活动停止这个服务或者活动被销毁的时候,该方法被调用. ​ 服务内部也可以自己调用stopSelf()来停止该服务. 3.2 启动和停止一个服务:​ 12345678protected void onCreate(Bundle savedInstanceState) &#123; //启动服务 Intent intent=new Intent(this,MyService.class); startService(intent); //停止服务 Intent intent2=new Intent(this,MyService.class); stopService(intent); &#125; 通常这样启用服务十分的不方便,当我们启动服务以后服务就一直在后台处于运行状态,除非执行完毕,否则我们就不知道服务在前在做什么,做到哪里了? 所以我们就需要服务和活动进行通讯. 3.3 服务和活动进行通讯: ​ 在服务中创建一个Binder实例类,并在Binder类中提供相对应的方法给别人调用. ​ 服务会通过public IBinder onBind(Intent intent) ;方法将Binder对象返回给活动. ​ 服务: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class MyService extends Service &#123; private static final String TAG = "MyService"; private Abinder mAbinder = new Abinder(); public MyService() &#123; Log.d(TAG, "MyService: "); &#125; @Nullable @Override public IBinder onBind(Intent intent) &#123; return mAbinder; &#125; @Override public void onCreate() &#123; super.onCreate(); Log.d(TAG, "onCreate: "); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Log.d(TAG, "onStartCommand: "); return super.onStartCommand(intent, flags, startId); &#125; @Override public void onDestroy() &#123; super.onDestroy(); Log.d(TAG, "onDestroy: "); &#125; class Abinder extends Binder &#123; public void start() &#123; Log.d(TAG, "start: "); &#125; public void pause() &#123; Log.d(TAG, "pause: "); &#125; public void resume() &#123; Log.d(TAG, "resume: "); &#125; public void restart() &#123; Log.d(TAG, "restart: "); &#125; public void destory() &#123; Log.d(TAG, "destory: "); &#125; &#125;&#125; 活动: 1234567891011121314151617181920212223242526272829303132public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private static final String TAG = "调试信息:"; private Button btn1, btn2, btn3, btn4, btn5; private MyService.Abinder mAbinder; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); Log.d(TAG, "onCreate: 当前活动线程:" + Thread.currentThread().getId()); &#125; private void initView() &#123; ... &#125; private ServiceConnection mServiceConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; Log.d(TAG, "onServiceConnected: "); mAbinder = (MyService.Abinder) service; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; Log.d(TAG, "onServiceDisconnected: "); &#125; &#125;;...... &#125; 通过上面完整的代码案列可以知道,在当前活动中通过于服务进行绑定可以获得一个service的内部对象,这个对象可以对service进行一定的控制和获取状态. 活动中创建了一个ServiceConnection的匿名内部类, 里面分别重写了 onServiceConnected(); onServiceDisconnected(); 这两个方法,当活动和服务进行绑定或解绑时他们会被调用. onServiceConnected(); 中 通过向下转型得到service的binder的实例,然后我们就可以通过这个实例对服务进行操作控制. 其中活动与服务的绑定方法接受三个参数 bindService(bindIntent,connection,BIND_AUTO_CREATE); 第一个参数是intent对象,指明我们的意图; 第二个参数是ServiceConnection的实例,它会在绑定成功或失败时回调这个对象中的方法; 第三个参数是BIND_AUTO_CREATE 这个当前Context提供的一个常量, 表示活动和服务进行绑定以后自动创建服务,所以服务中的onCreate()方法可以执行,但onStartCommand()方法不会执行. 注意点:当前程序中任何一个服务都可以与多个活动进行绑定,而且绑定后获取到的Binder实例也是相同的. 4. 服务的生命周期: Context中的strartService(): ​ onCreate()-&gt;onStartCommand()-&gt;onDestory() ​ 当这个服务第一次被创建的时候才会调用onCreate(); ​ 因为服务只有一个实例,所以不管调用多少次onStartCommand(),只需要调用stopService()就可以将服务销毁 Context中的bindService(): ​ onCreate-&gt;onBinder()-&gt;onDestroy() ​ 通过绑定来获取一个服务的持久化连接,这是会挥动服务中的onBind(),如果之前这个服务没有创建过,会先调用onCreate()方法. 之后就可以通过返回的Binder对象与服务进行通信. 调用unbindService()方法后 服务将会被销毁. ​ 当服务既调用了startService()又调用了bindService()时,因为Android系统的机制,一个服务只要被启动或绑定就一直处于运行状态,只有两种情况同时不满足这个服务才可以被销毁,所以要同时调用stopService()和unbindService() 这个服务才可以调用onDestroy() 5. 更高级的服务: 因为服务几乎都是在后台运行的,并且服务的优先级还是比较低的,当系统出现内存不足的情况,就有可能回收掉正在后台运行的服务.如果不想因为内存不足导致服务被回收,就可以考虑使用前台服务.前台服务和普通的服务的最大区别就在于,他会有一个正在运行的图标在系统的状态了显示,类似通知. 5.1 前台服务: ​ 只需要在Service的onCreate()方法中添加如下代码 123456789101112public void onCreate() &#123; super.onCreate(); Log.d(TAG, "onCreate: "); Intent intent = new Intent(this, MainActivity.class); PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, intent, 0); Notification notification = new NotificationCompat.Builder(this).setContentIntent (pendingIntent).setContentTitle("title").setContentText("text").setWhen(System .currentTimeMillis()).setSmallIcon(R.mipmap.ic_launcher).setLargeIcon (BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)).build(); startForeground(1, notification);&#125; 首先先创建一个通知,但和往常显示通过的方式不一样,它是通过调用startForeground()方法来显示; 这个方法接收两个参数:第一个参数时通知的Id;第二个参数则是构建出的Notification对象,调用这个方法以后就会将这个服务变成一个前台服务. 5.2 IntentService: 如果在服务中执行一些耗时的操作,可能需要在onStartCommand中开启子线程. 但是因为服务一直处于运行状态,想要让服务停止下来的话需要调用stopSelf() 或者stopService(); 但是经常会忘记开启线程或者调用停止服务的方法,所以Android 专门提供了一个IntentService类,这个类就解决了这两个问题. 用法: ​ 主要是创建一个继承自IntentService的类,并实现相应的方法; 方法 说明 构造函数(); 启动IntentService时调用,并赋值一个字符串给父类用于调试式判断工作线程 onHandleIntent(); 这个方法中的代码将会在子线程中执行 onDestroy(); 只要上面的方法执行完毕,就会调用这个方法停止当前服务. 123456789101112131415161718192021222324public class MyIntentService_ extends IntentService &#123; private static final String TAG = "调试信息:"; /** * Creates an IntentService. Invoked by your subclass's constructor. * * @param name Used to name the worker thread, important only for debugging. */ public MyIntentService_() &#123; super("name"); //name主要时用于调试时 方便知道工作在哪个线程 Log.d(TAG, "MyIntentService_: "); &#125; @Override protected void onHandleIntent(@Nullable Intent intent) &#123; Log.d(TAG, "onHandleIntent: 服务中的线程:"+Thread.currentThread().getId()); &#125; @Override public void onDestroy() &#123; super.onDestroy(); Log.d(TAG, "onDestroy: "); &#125;&#125; 12345678protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); Log.d(TAG, "onCreate: 当前活动线程:" + Thread.currentThread().getId()); Intent intent=new Intent(this,MyIntentService_.class); startService(intent); &#125; 通过调试信息可以看清楚IntentService的运行流程. 这样就十分方便了,后台的代码都在子线程中完成,并且执行完毕之后会自动停止服务.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fragment使用指南]]></title>
    <url>%2F2018%2F06%2F08%2FFragment%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[​ 碎片，是Android 3.0（API 11）提出的，为了兼容低版本，support-v4库中也开发了一套Fragment API，最低兼容Android 1.6。通过使用碎片可以降低我们程序的占用内存,复用布局 从而节省内存的开销. 1. 什么是碎片 ​ 碎片，是Android 3.0（API 11）提出的，为了兼容低版本，support-v4库中也开发了一套Fragment API，最低兼容Android 1.6。 过去support-v4库是一个jar包，24.2.0版本开始，将support-v4库模块化为多个jar包，包含：support-fragment, support-ui, support-media-compat等，这么做是为了减少APK包大小，你需要用哪个模块就引入哪个模块。 如果想引入整个support-v4库，则compile &#39;com.android.support:support-v4:24.2.1&#39;，如果只想引入support-fragment库，则com.android.support:support-fragment:24.2.1。 ​ 1. Fragment是依赖于Activity的，不能独立存在的。 ​ 2. 一个Activity里可以有多个Fragment。 ​ 3. 一个Fragment可以被多个Activity重用。 ​ 4. Fragment有自己的生命周期，并能接收输入事件。 5. 我们能在Activity运行时动态地添加或删除Fragment。 Fragment核心的类有： Fragment：Fragment的基类，任何创建的Fragment都需要继承该类。 FragmentManager：管理和维护Fragment。他是抽象类，具体的实现类是FragmentManagerImpl。 FragmentTransaction：对Fragment的添加、删除等操作都需要通过事务方式进行。他是抽象类，具体的实现类是BackStackRecord。 Nested Fragment（Fragment内部嵌套Fragment的能力）是Android 4.2提出的，support-fragment库可以兼容到1.6。通过getChildFragmentManager()能够获得管理子Fragment的FragmentManager，在子Fragment中可以通过getParentFragment()获得父Fragment。 ​ 优点:碎片的出现就是为了解决在正常3-6寸手机上显示正常,而到了某些大尺寸屏幕的设备上有些控件会过分拉长 元素之间空隙过大等情况,从而导致应用界面的不美观. 2. 碎片的使用方式2.1 基本的使用方式​ 首先定义一个碎片的布局,然后再java文件中通过findview….id()的方式找到这个布局 1234567891011121314151617//xml资源布局&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:background="#0000ff" android:layout_height="match_parent"&gt; &lt;Button android:id="@+id/button" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="点击" tools:layout_editor_absoluteX="0dp" tools:layout_editor_absoluteY="3dp" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 12345678910111213141516171819202122232425262728293031package example.h.fragment_demo2;import android.app.Activity;import android.content.Context;import android.os.Bundle;import android.support.annotation.NonNull;import android.support.annotation.Nullable;import android.support.v4.app.Fragment;import android.support.v4.app.FragmentManager;import android.util.Log;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;/** * code... * Created by H on 2018/4/30. */public class frag1 extends Fragment &#123; private String TAG="Fragment1的调试信息"; @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; View vie = LayoutInflater.from(getContext()).inflate(R.layout.f_layout1, container, false); MainActivity mainActivity= (MainActivity) getActivity(); mainActivity.test(); return vie; &#125;&#125; ​ 自此已经成功的定义了一个碎片了. ​ 那么如何使用这个碎片呢? 这只需要在活动的布局中添加控件就可以使用了 name属性指定要显示的碎片的名称(**.java) 其中必须设置每一个碎片的id 否者的话会产生一个致命错误导致程序蹦掉** 2.2 碎片与Activity或碎片之间的通信​ 在活动中与碎片通信: ​ 123456789101112131415161718192021222324252627282930package example.h.fragment_demo2;import android.os.Bundle;import android.support.annotation.NonNull;import android.support.annotation.Nullable;import android.support.v4.app.Fragment;import android.util.Log;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import static android.content.ContentValues.TAG;/** * code... * Created by H on 2018/5/2. */public class Fragment1 extends Fragment &#123; @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; View v = LayoutInflater.from(getContext()).inflate(R.layout.f_layout1, container, false); return v; &#125; public void test()&#123; Log.d(TAG, "test: 碎片中的方法被调用了"); &#125;&#125; ​ 12Fragment1 fragment1= (Fragment1) getSupportFragmentManager().findFragmentById(R.id.ddd); fragment1.test(); ​ 在活动中只需要简单的调用这两行代码就可以与碎片进行通信了. 在碎片中与活动通信: 12MainActivity mainActivity= (MainActivity) getActivity();mainActivity.test(); ​ 只需要在碎片中获取这个活动的实例就可以与活动进行通信了. 2.3 在碎片中模拟返回栈​ 当在一个碎片的基础上启动另外一个碎片的时候,点击back键这个程序直接退出了,如果想让它返回上一个碎片的话,需要在启动新的碎片前,把当前的碎片添加进返回栈 1234567891011121314private void replace(Fragment fragment) &#123; FragmentManager fragmentManager = getSupportFragmentManager(); //获取碎片的管理类 FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); //开启一个事务 fragmentTransaction.replace(R.id.right_layout, fragment); //向容器内添加或替换碎片,这里时替换 fragmentTransaction.addToBackStack(null); //事务提交之前 调用这个方法它可以接收一个名字用于描述返回栈的状态,一般传入null //这样默认点返回键就不会马上退出程序了. fragmentTransaction.commit(); //提交事务 &#125; 3. 碎片的生命周期 onAttach() 当碎片和活动建立关联的时候调用 onCreate() 当碎片被创建的时候调用 onCreateView(); 当碎片创建视图的时候调用 一般都i只实现这个方法 onActivityCreated() 确保与碎片相关联的的活动一定已经创建完毕的时候调用 onStart() 当碎片可见的时候调用 onResume() 当碎片可见且可交互时调用 碎皮已激活 onPause() 当碎片可见但不可交互的时候调用 onStop() 当碎片不可见时调用 onDestroyView() 当碎片的UI从视图结构中移除时调用 onDestroy() 当碎片被销毁时调用 onDetach() 当碎片和活动解除关联时调用 碎片销毁 4. 动态加载布局的技巧​ 通常一个应用如果没有给大尺寸的屏幕适配的话,这个App在这个手机上的显示效果就很差,有的控件会被过分拉长,或者间隙过大等等…如果你不想重新写一个app来适配平板的话,就可以在res文件夹中新建一个文件夹layout-large (限定符) 要在里面创建和layout同名的布局文件 app在运行的时候就会自动选择适合的布局 限定符(屏幕大小) 描述 small 提供给小屏幕设备的资源 normal 提供给中等屏幕设备的资源 large 提供给大屏幕设备的资源 xlarge 提供给超大屏幕设备的资源 限定符(分辨率) ldpi 提供给低分辨率设备的资源(120dpi以下) mdpi 提供给中等分辨率设备的资源(120dpi~160dpi) hdpi 提供给高分辨率设备的资源(160dpi~240dpi) xhdpi 提供给超高分辨率设备的资源(240dpi~320dpi) xxhdpi 提供给超超高分辨率设备的资源(320dpi~480dpi) 限定符(方向) land 提供给横屏设备的资源 port 提供给竖屏设备的资源 ## 如果创建了一个 layout-sw600dp(最小宽度限定符)文件夹,那么当屏幕的宽度小于600dp的时候它默认使用原来的布局资源,但是如果大于600dp则会使用layout-sw600dp文件夹中的布局资源]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ViewPager使用指南]]></title>
    <url>%2F2018%2F06%2F08%2FViewPager%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[ViewPager是Android开发者比较常用的一个控件了，由于它允许数据页从左到右或者从右到左翻页，因此这种交互也备受设计师的青睐。在APP中的很多场景都用得到，比如第一次安装APP时的用户引导页、图片浏览时左右翻页、广告Banner页等等都会用到ViewPager。 1. 什么是ViewPager?​ android.support.v4.view.ViewPager ​ v4扩展包中的一个类,用于实现view或者fragment在ViewPager上的左右切换. ​ ViewPager和之前常用LinearLayout一样,都是布局容器,我们可以在里面添加我们想要显示的内容但是每个viewpager都需要适配器,根据子项的不同选择不同的适配器. 2. ViewPager怎么用?​ 简单的先在xml中拉一个ViewPager控件,然后在活动中find到这个控件. 然后就是准备好要显示的内容比如view或者fragment什么的…添加到List中去 ,再去定义适配器.(和listview的用法差不多) 2.1 常用的基本方法: setAdapter(PagerAdapter adapter) 设置适配器 setOffscreenPageLimit(int limit) 设置缓存的页面个数,默认是 1 setCurrentItem(int item) 跳转到特定的页面 setOnPageChangeListener(..) 设置页面滑动时的监听器（现在API中建议使用 addOnPageChangeListener(..)） 添加… setPageTransformer(..PageTransformer) 设置页面切换时的动画效果 setPageMargin(int marginPixels) 设置不同页面之间的间隔 setPageMarginDrawable(..) 设置不同页面间隔之间的装饰图也就是 divide ，要想显示设置的图片，需要同时设置 setPageMargin() 2.2 适配器的选择 ​ 数据源:List -&gt;PagerAdapter ​ 数据源:List -&gt;FragmentPagerAdapter ​ 数据源:List -&gt;FragmentStatePagerAdapter 可以保存Fragment的状态 ​ PagerAdapter 是抽象的类，所有实现它的子类必须要实现以下四个方法. ​ getCount(); 获取当前窗口的数目 ​ isViewFromObject(View view,Object object); 判断当前的view是否由对象生产,官方建议直接返回view==object ​ instantiateItem(View container,int position); 当页面需要缓存或者显示的时候,会调用这个方法用于初始化布局 ​ destroyItem(ViewGroup container,int position,Object object); 不需要这个页面的时候(不显示也不需要缓存)的时候,会调用这个方法,销毁这个view ​ FragmentPagetAdapter:适用于具有少量的Fragment并且需要经常显示的情况,但是如果有大量的Fragment的时候请使用下面的适配器,因为通常用户访问每个页面的Fragment都保存在内存中,当页面不可见的时候这个Fragment可能会被摧毁但是会占用大量的内存.这是因为对于不再需要的Fragment仅销毁它的视图,并不会销毁Fragment的实例 ​ FragmentStatePagerAdapter:适用于当有大量的Fragment需要显示的时候, 当页面对用户不可见的时候,这个Fragment可能会被彻底的销毁,但是这使得pager保存的页面占用更少的内存. state 状态，销毁时，会将其 onSaveInstanceState(Bundle outState) 中的 bundle 信息保存下来，当用户切换回来，可以通过该 bundle 恢复生成新的 fragment,也就是说,你可以在 onSaveInstanceState(Bundle outState) 方法中保存一些数据,在 onCreate 中进行恢复创建. **总结下来:**只有少量的页面的时候可以使用第一种适配器.加载的时候比较快,但是如果有大量的页面的时候建议使用第二个,不过页面的切换时会产生更大的开销. (销毁以后新建) 2.3 需要显示的内容为Fragment​ 1234567891011121314151617181920 private ViewPager mViewPager; private List&lt;Fragment&gt; mFragmentList;protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView2(); &#125;private void initView2() &#123; mViewPager = findViewById(R.id.pager); mFragmentList = new ArrayList&lt;&gt;(); mFragmentList.add(new MyFragment()); mFragmentList.add(new MyFragment()); mFragmentList.add(new MyFragment()); mFragmentList.add(new MyFragment()); mFragmentList.add(new MyFragment()); mFragmentList.add(new MyFragment()); MyFragmentAdapter myFragmentAdapter = new MyFragmentAdapter(getSupportFragmentManager(), mFragmentList); mViewPager.setAdapter(myFragmentAdapter); &#125; ​ 适配器中需要重写两个方法 12345678910111213141516171819202122public class MyFragmentAdapter extends FragmentPagerAdapter &#123; private List&lt;Fragment&gt; mFragmentList; public MyFragmentAdapter(FragmentManager fm, List&lt;Fragment&gt; fragmentList) &#123; super(fm); mFragmentList = fragmentList; //fragment的添加和替换都是通过manager来管理的. &#125; @Override public Fragment getItem(int position) &#123; return mFragmentList.get(position); //用于展示的fragment &#125; @Override public int getCount() &#123; return mFragmentList.size(); //展示页面的个数 &#125;&#125; 2.4 需要显示的内容为View​ 123456789101112131415161718192021222324252627private ViewPager mViewPager; private List&lt;View&gt; mViews; private PagerAdapter mPagerAdapter; protected void onCreate(Bundle savedInstanceState) &#123; ... initView(); &#125; private void initView() &#123; mViewPager = findViewById(R.id.pager); mViews = new ArrayList&lt;&gt;(); mTabLayout = findViewById(R.id.tablayout); mTabLayout.setupWithViewPager(mViewPager); LayoutInflater layoutInflater = LayoutInflater.from(MainActivity.this); View view1 = layoutInflater.inflate(R.layout.item, null); mViews.add(view1); View view2 = layoutInflater.inflate(R.layout.item, null); mViews.add(view2); View view3 = layoutInflater.inflate(R.layout.item, null); mViews.add(view3); View view4 = layoutInflater.inflate(R.layout.item, null); mViews.add(view4); View view5 = layoutInflater.inflate(R.layout.item, null); mViews.add(view5); mPagerAdapter = new MyPagerAdapter(mViews); &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041public class MyPagerAdapter extends PagerAdapter &#123; private List&lt;View&gt; mViews; @Nullable @Override public CharSequence getPageTitle(int position) &#123; return arr[position]; &#125; public MyPagerAdapter(List&lt;View&gt; views) &#123; mViews = views; &#125; //必须重写下面四个方法 @Override public void destroyItem(@NonNull ViewGroup container, int position, @NonNull Object object) &#123; //super.destroyItem(container, position, object); //删除页卡 container.removeView(mViews.get(position)); &#125; @NonNull @Override public Object instantiateItem(@NonNull ViewGroup container, int position) &#123; //实例化页卡 container.addView(mViews.get(position)); return mViews.get(position); &#125; @Override public int getCount() &#123; //页卡个数 return mViews.size(); &#125; @Override public boolean isViewFromObject(@NonNull View view, @NonNull Object object) &#123; return view == object; &#125;&#125; ​ ​ 注意适配器中续要重写这四个方法即可 2.5 配合TabLayout使用​ 首先要在build.gradle中添加依赖: implementation ‘com.android.support:design:27.1.1’ ​ 通过上面的两个例子显示不同的控件需要使用不同的适配器. ​ 不过搭配TabLayout可以让人知道当前页面显示的是什么东西,并且想要跳跃到相对应的功能的时候也就更加的便捷与方便. 用法和一般的控件差不多,先在资源文件中添加这个控件声明id,然后通过活动findviewbyid()找到这个控件. 接下里在活动中绑定(viewpager等可以参考上面的代码) 1234567891011121314... //在viewpager和适配等初始化以及适配完毕了以后,调用下面的方法将Tablayout与ViewPager绑定起来.mTabLayout.setupWithViewPager(mViewPager); ... //下面是在适配器中 //接下来还需要在适配器中重写一个方法,否则标签栏不会显示信息 public CharSequence getPageTitle(int position) &#123; return arr[position]; //通过任意办法,把要显示的信息传进来, 他会根据页面的位置选择string,所以最好将信息的顺序与页面的顺序匹配起来 &#125; 3. 总结​ 通过上面的那些内容就可以简单的使用ViewPager并与TabLayout联合起来使用,不过ViewPager能做的不仅仅只是这一些,更多的可以看这篇文章:https://juejin.im/post/5a4c2f496fb9a044fd122631#heading-3]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 记录]]></title>
    <url>%2F2018%2F06%2F08%2FAndroid-Studio-%E9%87%87%E5%9D%91%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[这篇文章是为了记录使用Android Studio 中遇到的问题的解决办法,以及一些使用心得. 1. 快捷键: 快捷键 说明 Ctrl+Q 显示当前调用的方法的参数说明 Ctrl+Shift+F10 编译并运行程序 Ctrl+Alt+L 格式化代码,并自动对齐 Alt+Insert 快速插入get/set方法,以及构造方法等.. 经常需要重写的方法 Ctrl+Insert 快速新建一个类,活动或者服务 Ctrl+Alt+Left/Right 选中往左/右的一个代码单词 就可以不用一个个字母缓慢移动选中了 Ctrl+Alt+O 自动清除导入的包但是没有使用过的 Ctrl+Shift+Space 代码智能提示, 会自动补全 Ctrl+Alt+Space 代码提示,显示可能的构造方法或者接口 Ctrl+Shift+Up/Down 选中的代码向上或者向下移动 F2 快速跳转到代码报错的那一行 2. 故障解决:1. 运行安卓虚拟机出现:Emulator: Could not launch ‘C:\Users\H\AppData\Local\Android\Sdk\emulator/qemu/windows-x86_64/qemu-system-i386.exe’: No such file or directory 进入SDK Manager/SDK Tools 中将Android Emulator选中,点击apply等待下载完毕以后,确定退出,重新启动模拟器就可以运行了. 2.如何重启android studio的虚拟机 长按虚拟机的关机图标会跳出两个选项 (关机/重新启动); 3.怎么看调用一个方法时需要的参数？ 方法1：Ctrl+Q 方法2：Ctrl 然后鼠标移动到相应的方法上面。 2.写代码时，发现某个地方有下划红线怎么快速跳转到这个地方？ 按F2，先跳转到类 再按F2就可以跳转到相应的方法或者代码语句中。]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[BroadcastReceive使用指南]]></title>
    <url>%2F2018%2F06%2F08%2FBroadcastReceive%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[broadcast receiver 是一个用来响应系统范围内的广播的组件。 很多广播发自于系统本身。—例如, 通知屏幕已经被关闭、电池低电量、照片被拍下的广播。 应用程序也可以发起广播。—例如, 通知其它程序，一些数据被下载到了设备.当BroadcastReceive接收到系统发送的广播时就可以直接执行相对应的操作或者弹出一些界面与用户进行交互 1. 什么是BroadcastReceive? broadcast receiver 是一个用来响应系统范围内的广播的组件。 很多广播发自于系统本身。—例如, 通知屏幕已经被关闭、电池低电量、照片被拍下的广播。 应用程序也可以发起广播。—例如, 通知其它程序，一些数据被下载到了设备.当BroadcastReceive接收到系统发送的广播时就可以直接执行相对应的操作或者弹出一些界面与用户进行交互 通过继承BroadcastReceiver来实现广播的接收和操作 ，而且每一个广播通过Intent 对象来传递。 广播可以分为两类:标准广播(Normal broadcasts)和有序广播(Ordered broadcasts) ​ 标准广播: 是一种完全异步执行的广播,在广播发出以后几乎所有的广播接收器会在同一时刻接收到这条广播消息. ​ 有序广播: 是一种同步执行的广播,在广播发出以后同时只能有一个广播接收器接收,当这个广播接收器中的逻辑执行完毕以后,广播才会继续传递.所有此时的广播是有优先级的,优先级高的可以先接收到这个广播,并且还可以截断这个广播,后面的广播接收器就不会接收到这个广播了. 2. 怎样使用BroadcastReceive? ​ 需要创建一个继承自BroadcastReceiver类的子类并重写onReceive();方法 2.1 接收系统广播动态注册: 在代码中注册广播12345678public class MyBroadReceive extends BroadcastReceiver&#123; private static final String TAG = "MyBroadReceive"; @Override public void onReceive(Context context, Intent intent) &#123; Log.d(TAG, "onReceive: 接收到一条广播:"+intent.getAction()); &#125; //实例一个广播接收器类, 重写onReceive方法,当接收到注册到广播时,被该方法调用&#125; 123456789101112131415161718192021public class MainActivity extends AppCompatActivity &#123; private IntentFilter mIntentFilter; private MyBroadReceive mMyBroadReceive; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mIntentFilter = new IntentFilter(); mIntentFilter.addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED); mMyBroadReceive = new MyBroadReceive(); registerReceiver(mMyBroadReceive, mIntentFilter); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); unregisterReceiver(mMyBroadReceive); &#125; &#125; 需要实例一个广播接收器和IntentFilter并将希望接收到的广播添加进去,并将广播接收器和意图过滤器绑定 注意: 动态注册的广播一定要在退出之前取消注册,因为如果不取消注册的话该广播接收器将持有该activity的引用,activity在内存是不会被销毁的.严重的可能会导致内存溢出. 分析: 上面的案例是先新建一个BroadcastReceiver的子类并重写onReceive()方法;我们在活动中创建了一个IntentFilter的实例,并添加一个值为”android.intent.action.AIRPLANE_MODE”的action c ,这是当我们飞行模式发生变化时,系统会发送这样的一条广播,想监听什么广播就添加相应的action.接着创建MyBroadReceive的实例,通过registerReceiver();将IntentFilter的实例和MyBroadReceive的实例绑定起来. 这样我们就完成了广播的动态注册,不过在活动的最后需要调用unregisterReceiver();来取消广播接收器的注册. 运行程序以后,手动的开关飞行模式将会在控制台中输出 05-16 08:56:09.556 8937-8937/com.example.h.broadcast_demo1 D/MyBroadReceive: onReceive: 接收到一条广播:android.intent.action.AIRPLANE_MODE 这表明确实接收到了这样一条广播. 通过调用*.getAction();可以获取当前接收到的广播. 静态注册: 在ManiFest.xml中注册 相对于静态注册:动态注册只可以在当前程序启动的时候才可以接收到广播,而静态注册可以在程序没有开启的情况下接收广播并执行相对的逻辑操作. 新建 other/BroadercastReceiver 设置类名并将enable和exported打上勾,它就会在ManiFest.xml中自动为我们注册这个接收器.不管程序有没有打开都可以接收到这个广播 前提是要在 中添加想要接收的广播. ​ 1234567891011public class MyReceiver extends BroadcastReceiver &#123; private static final String TAG = "MyReceiver"; @Override public void onReceive(Context context, Intent intent) &#123; // TODO: This method is called when the BroadcastReceiver is receiving // an Intent broadcast. Toast.makeText(context, "接收到广播", Toast.LENGTH_LONG).show(); Log.d(TAG, "onReceive: 收到广播"); &#125;&#125; 12345678&lt;receiver android:name=".MyReceiver" android:enabled="true" android:exported="true"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.AIRPLANE_MODE" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; ​ 所有的静态广播接收器都是在ManiFest.xml中进行注册的,用法和activity相似 ​ name:指定具体注册哪一个广播接收器 ​ enabled:是否启动这个广播接收器 ​ exported:是否在程序以后接收广播 ​ 在标签中加如相应的标签就可以接收到指定的广播了 ​ 在这个程序中,只需要重启或者将当前的程序关闭,手动开动飞行模式就可以接收到该广播. ​ 2.2 发送自定义广播 ​ 构建一个Intent对象 并且可以把action当作参数进行初始化,通过sendBroadcast()传入intent对象来发送自定义广播,并且在MainFest.xml或Intent-Filter中添加action即可发送和接收这个广播. 发送有序广播: 新建两个接收相同广播的程序,并只在其中一个程序中发送广播,可以发现两个程序都可以接收到该广播 这个时候通过发送有序广播,并将第一个广播接收器的优先级设高,那么在广播被截断后,其他的接收器就接收不到这个广播了 #### 12345678910111213public class MyReceiver extends BroadcastReceiver &#123; private static final String TAG = "MyReceiver"; @Override public void onReceive(Context context, Intent intent) &#123; // TODO: This method is called when the BroadcastReceiver is receiving // an Intent broadcast. Toast.makeText(context, "接收到广播:"+intent.getAction(), Toast.LENGTH_LONG).show(); Log.d(TAG, "onReceive: 收到广播"); abortBroadcast();//广播将在这里被截断 后面的任何一个广播接收器都接收不到了 //打印出来是为了防止 运行程序时忘记看界面导致的不知道有没有接收到广播,而又要重新运行的尴尬问题 &#125;&#125; 1234567 //在活动中protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); sendOrderedBroadcast(new Intent("this a broadcast"),null); &#125; 123456789 &lt;!--在ManiFest.xml中定义接收的广播--&gt;&lt;receiver android:name=".MyReceiver" android:enabled="true" android:exported="true"&gt; &lt;intent-filter android:priority="100"&gt; &lt;action android:name="this a broadcast"/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 发送标准广播:123456789101112public class MyReceiver extends BroadcastReceiver &#123; private static final String TAG = "MyReceiver"; @Override public void onReceive(Context context, Intent intent) &#123; // TODO: This method is called when the BroadcastReceiver is receiving // an Intent broadcast. Toast.makeText(context, "接收到广播:"+intent.getAction(), Toast.LENGTH_LONG).show(); Log.d(TAG, "onReceive: 收到广播"); //打印出来是为了防止 运行程序时忘记看界面导致的不知道有没有接收到广播,而又要重新运行的尴尬问题 &#125;&#125; 1234567 //在活动中protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); sendBroadcast(new Intent("this a broadcast")); &#125; 通过构建意图来发送广播. 不过如果另外一个程序也接收了一个这样的广播,两个程序是可以几乎同时接收到的. 由于发送自定义广播是用Intent进行传递的而且Intent中也可以携带一些数据传递给接收器,而这就可能导致我们发送广播时附加的数据被其它程序接收到导致数据泄露.又或者程序向我们的接收器不停的发送垃圾广播,这时候就可以使用本地广播了. 2.3 使用本地广播 为了解决广播的安全性问题,Google引入了本地广播机制,使用这个机制发出的广播只能在应用程序的内部进行传递,并且广播接收器只能接收来自本程序发出的广播. 使用LocalBroadcastManager对象对广播进行管理,使发出的广播只在程序内部进行传递,并且只能被程序内的广播接收器接收. 12345678910111213141516171819202122232425262728293031323334public class MainActivity extends AppCompatActivity &#123; private LocalBroadcastManager mLocalBroadcastManager; private IntentFilter mIntentFilter; private localBroadcastReceive mLocalBroadcastReceive; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mLocalBroadcastManager = LocalBroadcastManager.getInstance(this); mIntentFilter = new IntentFilter(); mIntentFilter.addAction("other_broadcast"); mLocalBroadcastReceive = new localBroadcastReceive(); mLocalBroadcastManager.registerReceiver(mLocalBroadcastReceive, mIntentFilter); Intent intent = new Intent("other_broadcast"); mLocalBroadcastManager.sendBroadcast(intent); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); mLocalBroadcastManager.unregisterReceiver(mLocalBroadcastReceive); &#125; class localBroadcastReceive extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, "本地广播:"+intent.getAction(), Toast.LENGTH_SHORT).show(); &#125; &#125;&#125; 本地广播和之前动态注册广播接收器以及发送广播的代码是差不多的,这里通过LocalBroadcastManager对象来发送广播和注册(取消注册)广播,并且其他程序的广播不会到本程序内部,本程序的广播也不会被其他的程序接收到. 此外本地广播是不能静态注册的,因为发送本地广播时我们的程序肯定已经启动了,而静态注册是为了即使程序在未启动的状态下也可以接收广播.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
</search>
